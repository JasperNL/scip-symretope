/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/*                                                                           */
/*                  This file is part of the program and library             */
/*         SCIP --- Solving Constraint Integer Programs                      */
/*                                                                           */
/*    Copyright (C) 2002-2021 Konrad-Zuse-Zentrum                            */
/*                            fuer Informationstechnik Berlin                */
/*                                                                           */
/*  SCIP is distributed under the terms of the ZIB Academic License.         */
/*                                                                           */
/*  You should have received a copy of the ZIB Academic License              */
/*  along with SCIP; see the file COPYING. If not visit scipopt.org.         */
/*                                                                           */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/**@file   permutation.h
 * @brief  type definitions for permutations
 * @author Jasper van Doornmalen
 */

/*---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8----+----9----+----0----+----1----+----2*/

#include "scip/scip.h"

#ifdef __cplusplus
extern "C" {
#endif


/** Permutation specification */
typedef struct SCIP_Permutation SCIP_PERMUTATION;
struct SCIP_Permutation
{
   int*                  perm;               /**< permutation associated to the symresack */
   SCIP_Longint          order;              /**< the order of the group generated by the permutation */
   int                   nvars;              /**< number of variables */
   int**                 cycles;             /**< Pointers to the cycle starts in the cycle decomposition of the permutation */
   int*                  cycleblock;         /**< The array storing all cycles of the cycle decomposition of the permutation */
   int                   ncycles;            /**< The number of cycles in the cycle decomposition */
   int*                  cyclelengths;       /**< The length of each cycle in the cycle decomposition */
   int                   maxcyclesize;       /**< The maximal size of a cycle in the permutation */
   // int*                  cyclelengthsind;    /**< The index of the cycle length in diffcyclelengths.*/
   // int*                  diffcyclelengths;   /**< The different cycle lengths popping up in the cycle decomposition */
   // int                   ndiffcyclelengths;  /**< The number of different cycle lengths */
   // int                   maxndiffcyclelengths; /**< An upper bound on the maximal number of different cycle lengths. */
   int*                  varcycle;           /**< For each variable index, the index of the cycle that contains this */
   int*                  varcyclepos;        /**< For each variable index, the position in the cycle that contains this */
   SCIP_Bool             ismonotone;         /**< Whether the generating permutation is monotonous */
   SCIP_Bool             isordered;          /**< Whether the generating permutation is ordered */
};


/** Compute the greatest common divisor of two nonnegative integers
 * @param a First integer, nonnegative
 * @param b Second integer, nonnegative
 * @return The greatest common divisor of a and b.
 */
SCIP_EXPORT
SCIP_Longint gcd(
   SCIP_Longint a,
   SCIP_Longint b
);


/** Compute the least common multiple of two nonnegative integers
 * @param a First integer, nonnegative
 * @param b Second integer, nonnegative
 * @return The least common multiple of a and b.
 */
SCIP_EXPORT
SCIP_Longint lcm(
   SCIP_Longint a,
   SCIP_Longint b
);


/** Get a permutation object from a permutation array.
 * @param scip The SCIP instance.
 * @param perm The permutation on 0..nvars-1, where entry i of this vector is the value that entry i permutes to.
 * @param nvars The number of variables in the array.
 * @return A SCIP_PERMUTATION object for this permutation.
 */
SCIP_EXPORT
SCIP_RETCODE SCIPgetPermutation(
   SCIP* scip,
   int* perm,
   int nvars,
   SCIP_PERMUTATION* permutation
);


/** Given a SCIP_PERMUTATION object, give the entry on which we apply the permutation pow times.
 * @param perm The SCIP_PERMUTATION object
 * @param index The index that we want to permute.
 * @param pow The power for which we want to permute.
 * @return The entry.
 */
SCIP_EXPORT
int permGet(
   SCIP_PERMUTATION* perm,                   /**< the permutation */
   int index,                                /**< entry to permute */
   int pow                                   /**< power to permute */
);


/** Given a SCIP_PERMUTATION object, give the permutation array that maps 0..nvars to the permutation raised to a power.
 * @param perm The SCIP_PERMUTATION object
 * @param pow The power for which we want to permute.
 * @param arr The allocated array to store the permutation in.
 * @param nvars The number of variables of the permutation. The array size should match with this.
 * @return SCIP_OKAY if successful.
 */
SCIP_EXPORT
SCIP_RETCODE getPermArray(
   SCIP_PERMUTATION* perm,
   SCIP_Longint pow,
   int* arr,
   int nvars
);


/** Free a SCIP_PERMUTATION object.
 * @param scip the SCIP instance
 * @param permutation The SCIP_PERMUTATION object
 * @param freePerm Whether the field "perm" of SCIP_PERMUTATION must be freed, as well. \
 *    This is a reference to the original permutation array that was used for this object.
 * @return SCIP_OKAY if successful.
 */
SCIP_EXPORT
SCIP_RETCODE SCIPfreePermutationContents(
   SCIP* scip,
   SCIP_PERMUTATION* permutation,
   SCIP_Bool freePerm
);


#ifdef __cplusplus
}
#endif
